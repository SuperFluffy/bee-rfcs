+ Feature name: `bee-hash`
+ Start date: 2019-10-15
+ RFC PR: [iotaledger/bee-rfcs#0000](https://github.com/iotaledger/bee-rfcs/pull/0000)
+ Bee issue: [iotaledger/bee#0000](https://github.com/iotaledger/bee/issues/0000)

# Summary

Hash functions in IOTA are sponge construction which usually hash an internal start to absorb input stream and output
stream in any desired length after permutation. That means they all share similar structure we are able to abstract
with. The goal of this RFC is to model this Sponge layer as trait. Making low-level hash algorithms provide same logic
interface exposed to user, and let high-level module able to loosely couple from them.

# Motivation

It's true that everyone can just use each hash function they want directly. But we should still prevent from any of
these algorithm is too tightly coupled to upper module when we integrate this. Take proof of work for example, it will
have a module called PearlDiver mainly to deal with hashing. In the past, it already switched from curl-p to kerl.
Imagine these two functions have totally different API, it would be difficult to refactor. Same thing is going to happen
when we migrate to troika or other secure cryptography primitives in the future. So defining a trait for sponge is the
best and necessary approach for us. 

# Detailed design

This trait is going to be the interface of any sponge construction. Imagine it's like a real sponge, it `absorb`s the
clone of input reference provided by users. And they don't need to know how internal permutation and transformation
work, just `squeeze` the sponge and there will be a mutable reference as output. The internal state will not be cleared
unless `reset` is called.

```rust 
pub trait Sponge
where
    Self: Default + Clone + Send + 'static,
{
    /// Absorb trits into the sponge
    fn absorb(&mut self, input: &[Trit]);
    /// Squeeze trits out of the sponge and copy them into `out`
    fn squeeze(&mut self, output: &mut [Trit]);
    /// Reset the sponge to initial state
    fn reset(&mut self);
    /// Digest inputs and then compute the hash with length of provided output slice
    fn digest (&mut self, input: &[Trit], output: &mut [Trit]) {
        self.absorb(input);
        self.squeeze(output);
    }
}
```
# Drawbacks

- Somebody may just want to use each function directly without methods of this trait.
- This trait only suit for sponge functions and also focus on ternary system. It's not compatible to other binary
	cryptography.

# Rationale and alternatives

- `Sponge` trait provide a common interface suit for any type of sponge functions.
- This trait is idiomatic in Rust. Users are not required to know the implement details of each hash algorithm.
- We still have option to just use `Digest` crate, but it's parameters are all type of `u8`. IOTA use trits as basic
	type which means this library may not fit our need.

# Unresolved questions

- Required and provided methods better resolve through RFC process. Do methods like `new` & `transform` also need to be
	abstracted in `Sponge` trait?   
- Parameters are slice reference in both input and output. Do we want to consume value or create a new instance as
	return values?
- Should we have low level traits defined like Digest? If so, should we also provide macro to implement these traits
	easily?
- Implementation of each hash functions and other utilities like HMAC should have separate RFCs for them.
