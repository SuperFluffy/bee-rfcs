+ Feature name: `bee-hash`
+ Start date: 2019-10-15
+ RFC PR: [iotaledger/bee-rfcs#0000](https://github.com/iotaledger/bee-rfcs/pull/0000)
+ Bee issue: [iotaledger/bee#0000](https://github.com/iotaledger/bee/issues/0000)

# Summary

Hash functions in IOTA are sponge construction which usually hash an internal start to absorb input stream and output
stream in any desired length after permutation. That means they all share similar structure we are able to abstract
with. The goal of this RFC is to model this Sponge layer as trait. Making low-level hash algorithms provide same logic
interface exposed to user, and let high-level module able to loosely couple from them.

# Motivation

It's true that everyone can just use each hash function they want directly. But we should still prevent from any of
these algorithm is too tightly coupled to upper module when we integrate this. Take proof of work for example, it will
have a module called PearlDiver mainly to deal with hashing. In the past, it already switched from curl-p to kerl.
Imagine these two functions have totally different API, it would be difficult to refactor. Same thing is going to happen
when we migrate to troika or other secure cryptography primitives in the future. So defining a trait for sponge is the
best and necessary approach for us. 

# Detailed design

// TODO: Demonstrate what sponge construction is

```rust 
pub trait Sponge {
	/// Absorb trits into the sponge
	fn absorb(&mut self, trits: &[Trit]);
	/// Squeeze trits out of the sponge and copy them into `out`
	fn squeeze(&mut self, out: &mut [Trit]);
	/// Reset the sponge to initial state
	fn reset(&mut self);
}
```
# Drawbacks

- Somebody may just want to use each function directly without methods of this trait.
- This trait only suit for sponge functions and also focus on ternary system. It's not compatible to other binary
	cryptography.

# Rationale and alternatives

- `Sponge` trait provide a common interface suit for any type of sponge functions.
- This trait is idiomatic in Rust. Users are not required to know the implement details of each hash algorithm.
- We still have option to just use `Digest` crate, but it's parameters are all type of `u8`. IOTA use trits as basic
	type which means this library may not fit our need.

# Unresolved questions

- Required and provided methods better resolve through RFC process.
- Should we have low level traits defined like Digest? If so, should we also provide macro to implement these traits
	easily?
- Implementation of each hash functions and other utilities like HMAC should have separate RFCs for them.
