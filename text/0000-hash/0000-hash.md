+ Feature name: `bee-hash`
+ Start date: 2019-10-15
+ RFC PR: [iotaledger/bee-rfcs#0000](https://github.com/iotaledger/bee-rfcs/pull/0000)
+ Bee issue: [iotaledger/bee#0000](https://github.com/iotaledger/bee/issues/0000)

# Summary

Hash functions in IOTA are sponge construction which usually hash an internal start to absorb input stream and output
stream in any desired length after permutation. That means they all share similar structure we are able to abstract
with. In current IRI and all supported client libraries in different language, `Curl` and `Kerl` are served in different
task. While `Curl` with 27 rounds is no longer used, `Curl` still handles proof of work and transaction hash generation.
`Kerl` is responsible for the rest cryptography secure operations. There is also another hash function designed by
Cryptocrypt which is still under cryptanalysis. Although we haven't determined to replace all tasks with `Troika`, we
might also want to consider it when designing `Sponge` trait Espcially `Troika` doesn't use balanced trits as `Curl` and
`Kerl` do. The goal of this RFC is to model this Sponge layer as trait. Making low-level hash algorithms provide same
logic interface exposed to users. 

Useful links:

- [The sponge and duplex constructions](https://keccak.team/sponge_duplex.html)
- [Curl-p]()
- [Kerl specification](https://github.com/iotaledger/kerl/blob/master/IOTA-Kerl-spec.md)
- [Troika specification](https://www.cyber-crypt.com/troika/)

# Motivation

It's true that everyone can just use each hash function they want directly. But we should still prevent from any of
these algorithm is too tightly coupled to upper module when we integrate this. Take proof of work for example, it has a
module called PearlDiver mainly to deal with hashing. The hash algorithm for PearlDiver is still `Curl`. But at the
meantime, most of other tasks already switch from `Curl` to `Kerl`.  Imagine these two functions have totally different
API, it would be difficult to refactor. Same thing is going to happen when we migrate to `Troika` or other secure
cryptography primitives in the future. So defining a trait for sponge is the best and necessary approach for us. We
expect users will still create each instance with each module structure methods but share same method signatures like
this: 

```rust
// Create a Curl instance with default rounds number which is 81.
let mut curl = Curl::default();
// Assume this is a transaction and we want to digest a hash.
let transaction = [0i8; 8019];
let mut tx_hash = [0i8; 243];

// `digest` is a provided method of Sponge which can separate with `absorb` & `squeeze` alternatively.
// curl.absorb(&transaction);
// curl.squeeze(&mut tx_hash);
curl.digest(&transaction, &mut tx_hash);


// That said we have `Kerl` and would like to hash with this instead.
let mut kerl = Kerl::default();

// Same trait methods are called and signatures are not changed. Separate methods are still available.
// kerl.absorb(&transaction);
// kerl.squeeze(&mut tx_hash);
kurl.digest(&transaction, &mut tx_hash);
```

# Detailed design

This trait is going to be the interface of any sponge construction. Imagine it's like a real sponge, it `absorb`s the
clone of input reference provided by users. And they don't need to know how internal permutation and transformation
work, just `squeeze` the sponge and there will be a mutable reference as output. The internal state will not be cleared
unless `reset` is called.

```rust 
pub trait Sponge
where
    Self: Default + Clone,
{
    type Item = Trit;

    /// Absorb trits into the sponge
    fn absorb(&mut self, input: &[Self::Item]);
    /// Squeeze trits out of the sponge and copy them into `out`
    fn squeeze(&mut self, output: &mut [Self::Item]);
    /// Reset the sponge to initial state
    fn reset(&mut self);
    /// Digest inputs and then compute the hash with length of provided output slice
    fn digest (&mut self, input: &[Self::Item], output: &mut [Self::Item]) {
        self.absorb(input);
        self.squeeze(output);
    }
}
```
# Drawbacks

- Users may just want to use each function directly without methods of this trait.
- This trait doesn't completely decouple implementation between layers. It just provides a common interface.
- This trait only suit for sponge functions and also focus on ternary system. It might not be compatible to other binary
	cryptography.
- There is a sponge-less curl implementation optimized for performing proof of work. It might not be benefited from this
	trait.

# Rationale and alternatives

- `Sponge` trait provide a common interface suit for any type of sponge functions.
- This trait is idiomatic in Rust. Users are not required to know the implement details of each hash algorithm.
- We still have option to just use `Digest` crate, but it's parameters are all type of `u8`. IOTA use trits as basic
	type which means this library may not fit our need. The ecosystem of this crate is also not fully mature yet. It may
	be a burden to add another dependency.
- Crypto community in Rust usually don't rely on native crates written all in Rust. Like
	[sodiumoxide](https://github.com/sodiumoxide/sodiumoxide) is a Rust binding to
	[libsodium](https://github.com/jedisct1/libsodium). There's also [ring](https://github.com/briansmith/ring) in a
	hybrid of Rust, C, and assembly language which also expose a Rust API. However, utilize libraries like these will also
	need to take care of different language bindings and their foreign function interface. There will be unsafe scenarios
	have to consider more over. It will be better for us to stick with full Rust at the moment. In deed there's RustCrypto
	community provides various crates and utilities like `Digest`. But like it states above, the ecosystem is not truely
	mature yet. As this more low-level concer, we should make less dependency as possible.

# Unresolved questions

- Required and provided methods better resolve through RFC process. Do methods like `new` & `transform` also need to be
	abstracted in `Sponge` trait?   
- Parameters are slice reference in both input and output. Do we want to consume value or create a new instance as
	return values?
- Should we have low level traits defined like Digest? If so, should we also provide macro to implement these traits
	easily?
- Implementation of each hash functions and other utilities like HMAC should have separate RFCs for them.
